<!DOCTYPE html>
<html>
<head>
  <title></title>
</head>
<body>

<script>
Math.toDegrees = function(angleInRadians){
  return angleInRadians * (180/Math.PI)
}

Math.toRadians = function(angleInDegrees){
  return angleInDegrees * (Math.PI/180)
}

var data = {
  "v": 327.790863885601,
  "sma": 899865.909004628,
  "maae": 1.71700514682077,
  "e": 0.242086099014791,
  "inclination": 0.243482974210391,
  "lan": 100.67407197386,
  "aop": 91.1833452819551,
  "latitude": 0.208644159455845,
  "longitude": 41.9663712098415,
  "orbitalPeriod": 2854.04497711937,
  "angV": 0.0002155695
}

var eccentricity = data["e"] //no unit
var trueAnomalyInDegrees = data["v"] //degrees
var trueAnomalyInRadians = Math.toRadians(trueAnomalyInDegrees) //radians
var gravitationalParameter = 3531600000000 // Gm/s^2
var semiMajorAxis = data["sma"] //meters
var startTime = 0 //seconds
var endTime = 0 //seconds
var inclinationInDegrees = data["inclination"] // degrees
var inclinationInRadians = Math.toRadians(inclinationInDegrees) // radians
var longitudeOfAscendingNodeInDegrees = data["lan"] //degrees
var longitudeOfAscendingNodeInRadians = Math.toRadians(longitudeOfAscendingNodeInDegrees) //radians
var argumentOfPeriapsisInDegrees = data["aop"] //degrees
var argumentOfPeriapsisInRadians = Math.toRadians(argumentOfPeriapsisInDegrees) //radians
var orbitalPeriod = data["orbitalPeriod"] // seconds
var angularVelocityOfVessel = data["anvV"] // meters/second
var universalGravitationalParameter = 6.673999953095288e-11
var rotationalPeriodOfKerbin = 21599.9120145401 //seconds


function eccentricAnomalyFromTrueAnomalyAndEcentricity(trueAnomaly, eccentricity){
  var cosineE = (eccentricity + Math.cos(trueAnomaly))/(1 + (eccentricity* Math.cos(trueAnomaly)))
  return Math.acos(cosineE)
}

function meanMotion(semiMajorAxis, gravitationalParameter){
  return (2 * Math.PI)/(orbitalPeriod)
  // return Math.sqrt(gravitationalParameter/Math.pow(semiMajorAxis, 3))
}

function meanAnomalyFromEccentricAnomalyAndEccentricity(eccentricAnomaly, eccentricity){
  return eccentricAnomaly - eccentricity * Math.sin(eccentricAnomaly)
}

function meanAnomalyAtTimeAndMeanMotion(meanMotion, time, originalMeanAnomaly){
  var deltaT = time - startTime
  return originalMeanAnomaly + meanMotion * deltaT
}

function estimateEccentricAnomalyFromMeanAnomalyAndEccentricity(meanAnomaly, eccentricity){
  var error = 100
  var eccentricAnomaly1 = meanAnomaly
  // var i = 10

  while(error > 0.00000000001){
    var newEccentricAnomaly = meanAnomaly + (eccentricity * Math.sin(eccentricAnomaly1))
    error = Math.abs(newEccentricAnomaly - eccentricAnomaly1)
    // console.log("newEccentricAnomaly: " + newEccentricAnomaly)
    // console.log("error: " + error)
    // i--
    // debugger
    eccentricAnomaly1 = newEccentricAnomaly
  }
  return eccentricAnomaly1
}

function trueAnomalyFromEccentricAnomalyAndEccentricity(eccentricAnomaly, eccentricity){
  var factor1 = Math.sqrt(1.0 - Math.pow(eccentricity, 2)) * Math.sin(eccentricAnomaly)
  var factor2 = Math.cos(eccentricAnomaly) - eccentricity

  if(longitudeOfAscendingNodeInDegrees > 90 && longitudeOfAscendingNodeInDegrees <= 360){
    var inversion = Math.toRadians(360)
  } else{
    var inversion = 0
  }

  return inversion - Math.atan2(factor1, factor2)
}

function findSemiLatusRectum(semiMajorAxis, eccentricity){
  return semiMajorAxis * (1 - Math.pow(eccentricity, 2))
}

function findPolarEquationOfConic(semiMajorAxis, eccentricity, trueAnomaly){
  var p = findSemiLatusRectum(semiMajorAxis, eccentricity)

  return p/(1 + eccentricity * Math.cos(trueAnomaly))
}

function positionVectorInPQWFrame(semiMajorAxis, eccentricity, trueAnomaly){
  var r = findPolarEquationOfConic(semiMajorAxis, eccentricity, trueAnomaly)
  var vector = {}
  vector.p = r * Math.cos(trueAnomaly)
  vector.q = r * Math.sin(trueAnomaly)
  vector.w = 0
  return vector
}

function velocityVectorInPQWFrame(semiMajorAxis, eccentricity, trueAnomaly, gravitationalParameter){
  var p = findSemiLatusRectum(semiMajorAxis, eccentricity)
  var factor = Math.sqrt(gravitationalParameter/p)
  var vector = {}
  vector.p = -Math.sin(trueAnomaly)
  vector.q = eccentricity + Math.cos(trueAnomaly)
  vector.w = 0
  return vector
}

// Thank god for: https://en.wikipedia.org/wiki/Perifocal_coordinate_system
function transformPositionPQWVectorToIJKFrame(vector, inclination, longitudeOfAscendingNode, argumentOfPeriapsis){
  var vectorIJK = {}
  var omega = longitudeOfAscendingNode
  var w = argumentOfPeriapsis
  var i = inclination

  vectorIJK.i = Math.cos(omega) * Math.cos(w) - Math.sin(omega) * Math.cos(i) * Math.sin(w)
  vectorIJK.j = Math.sin(omega) * Math.cos(w) + Math.cos(omega) * Math.cos(i) * Math.sin(w)
  vectorIJK.k = Math.sin(i) * Math.sin(w)

  return vectorIJK
}

function findLatitudeOfPositionUnitVector(vector){
  var x = Math.sqrt(Math.pow(vector.i, 2) + Math.pow(vector.j, 2))
  var z = vector.k
// 
  return Math.atan(z/x)
}

function findLongitudeOfPositonUnitVector(vector, angularVelocityOfPlanet, time){
  var deltaT = time - startTime
  var quadrant = vector.j > 0 ? 1 : -1
  var theta = Math.atan(vector.i/vector.j)
  return theta - 0 - angularVelocityOfPlanet * deltaT
}

var E = eccentricAnomalyFromTrueAnomalyAndEcentricity(trueAnomalyInRadians, eccentricity)
var n = meanMotion(semiMajorAxis, gravitationalParameter)
var meanAnomaly = meanAnomalyFromEccentricAnomalyAndEccentricity(E, eccentricity)
var estimatedE = estimateEccentricAnomalyFromMeanAnomalyAndEccentricity(meanAnomaly, eccentricity)
var estimatedV = trueAnomalyFromEccentricAnomalyAndEccentricity(E, eccentricity)


var positionVectorInPQW = positionVectorInPQWFrame(semiMajorAxis, eccentricity, trueAnomalyInRadians)
var positionVectorInIJK = transformPositionPQWVectorToIJKFrame(positionVectorInPQW, inclinationInRadians, longitudeOfAscendingNodeInRadians, argumentOfPeriapsisInRadians)
var latitude = findLatitudeOfPositionUnitVector(positionVectorInIJK)


var meanAnomalyAtTime1 = meanAnomalyAtTimeAndMeanMotion(n, endTime, meanAnomaly)
var eccentricAnomalyAtTime1 = estimateEccentricAnomalyFromMeanAnomalyAndEccentricity(meanAnomalyAtTime1, eccentricity)
var trueAnomalyAtTime1 = trueAnomalyFromEccentricAnomalyAndEccentricity(eccentricAnomalyAtTime1, eccentricity)

console.log("***** t0 *****")

console.log("eccentricity: " + eccentricity)
console.log("v: " + trueAnomalyInRadians)
console.log("E: " + E)
console.log("n: " + n)
console.log("meanAnomaly: "  + meanAnomaly)
console.log("estimated E: " + estimatedE)
console.log("estimated v: " + estimatedV)
console.log("positionVector (PQW):" + JSON.stringify(positionVectorInPQW))
console.log("positionVector (IJK):" + JSON.stringify(positionVectorInIJK))
console.log("latitude: " + latitude)

console.log("***** t1 *****")

console.log("meanAnomalyAtTime1: " + meanAnomalyAtTime1)
console.log("eccentricAnomalyAtTime1: " + eccentricAnomalyAtTime1)
console.log("trueAnomalyAtTime1: " + trueAnomalyAtTime1)

</script>
</body>
</html>